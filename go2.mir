import java.util.ArrayList

class RubyObj

  # def +(o:Object):RubyObj # rubyobj???
  #   raise 'not yet implemented'
  # end
  # 
  # def -(o:RubyObj):RubyObj # ?? do we need minus here or...should it be ImplementsMinus prolly the latter
  #   raise 'not yet implemented'
  # end

end

interface ImplementsMinusOneArg do
  def -(o:RubyObj):RubyObj
  end
end

interface ImplementsPlusOneArg do
  def +(o:RubyObj):RubyObj
  end
end


interface ImplementsToI do
  def to_i():int
  end
end

interface CallableOneArg do
  def call(arg1:RubyObj):RubyObj
  end
end

interface TimesZeroArgBlockOneArg do
  def times2(block:CallableOneArg):RubyObj
  end
end

# should I make this class static? cache it [in a hash]?
class RubyInt < RubyObj
  implements ImplementsToI
  implements TimesZeroArgBlockOneArg
  implements ImplementsMinusOneArg
  implements ImplementsPlusOneArg

  def initialize(a:int) # numeric ?
    @a = a
  end
  
  def initialize(incoming:RubyObj)
    @a = ImplementsToI(incoming).to_i
  end
  
  $Override
  def yoyo()
  end
  

  $Override # ?? doesn't actually do anything?
  def +(o:RubyObj) # Object? prolly wouldnt help me here...
    # @a is an int
    RubyInt.new(@a + ImplementsToI(o).to_i)
  end
  
  # XXX overflow ?

  $Override
  def -(o:RubyObj):RubyObj
    RubyInt.new(@a - ImplementsToI(o).to_i)
  end

  $Override
  def to_i():int # ummm..shouldn't it complain if I don't have this?
    @a
  end

  $Override
  def toString # any way to provide for free?
    '' + @a
  end

  $Override
  def times2(block:CallableOneArg):RubyObj
    x = 0
    #for(x = 0; x < @a; x += 1) # ??
    while x < @a
        block.call(RubyInt.new(x)) # XXXX reuse the rubyint obj? make it frozen too somehow? FrozenRubyInt?
#     x++# ?
        x += 1
    end
    self
  end

end

interface CallableOneArg do
  def call(arg1:RubyObj):RubyObj
  end
end

interface BracketOneArg do
  def [](offset:ImplementsToI):RubyObj
  end
end

# interfaces are loosy-goosey! Suh-weet!

class RubyArray < ArrayList # ArrayList<RubyObj>
  implements BracketOneArg
  #def <<(o:RubyObj) # ??
  #  add o
  #end

  def [](idx:RubyObj):RubyObj 
    # call to_i is what ruby seems to always do...
    RubyObj(get(ImplementsToI(idx).to_i))
  end
  

  # do we really need this? hmm...
  def [](idx:int):RubyObj # ImplementsToI ? ImplementsToI# [1,2,3][fake_obj] =>     TypeError: can't convert Yo to Integer (Yo#to_int gives Array)
    RubyObj(get(idx))
  end

  def initialize(o:java.util.List)
    #    super # should work?
    #    super(o) # should work?
    #puts 'in init' # we get here...
    addAll(o)
  end

end

# specs :)

RubyInt.new(1) - RubyInt.new(2)
RubyInt.new(1) + RubyInt.new(2)
# RubyInt.new(1).times { } # ??

# RubyInt.new(1).times do |n| ??
  
# end


RubyInt.new(1).times2 do |n|
  
end

def calcFibN(num:RubyObj)
  fib_array = RubyArray.new [RubyInt.new(0), RubyInt.new(1)]
  
#  TimesZeroArgBlockOneArg(num-RubyInt.new(2)).times2 do |i| # ??
  RubyInt.new(ImplementsMinusOneArg(num)-RubyInt.new(2)).to_i.times do |i|
    # XXXX not need RubyObj class...I think...for now...
    fib_array.add(RubyObj(fib_array[i]) + RubyObj(fib_array.get(i+1)))
  end
  # puts fib_array
end

3_000_000.times {
  calcFibN(RubyInt.new(30))
}

