#
# the std lib/common hand-brew interfaces
#

import java.util.ArrayList

# eventually we'll probably need this class for doing the "system" or whatever the Kernel shtuff is...

# Note that I've munged -, +, and <<, and should munge == and []= though the latter might be ok...

class RubyObj

  def this
   self
  end

  $Override
  def equals(o:Object):boolean
    raise 'not implemented' + self.toString # the inner classes need to implement this or they are hosed
  end

end

interface Implements__equals do

  def equals(o:RubyObj):boolean # I guess this will force them to output a boolean last statement, which is ok
  # what about them wanting to be able to output void (or "a boolean here" or what not...)
  
  # I wonder if there's a better way somehow...like class RubyInt: def equals(RubyInt); but I can't think of one right now off the top of my head.
  
  end
end

interface ImplementsLessThanLessThanOneArg do
  def lessThanLessThan(o:RubyObj):RubyObj
  end
end

interface ImplementsLessThanLessThanOneArg2 do
  def lessThanLessThan33(o:RubyObj):RubyObj
  end
end


interface ImplementsMinusOneArg do
  def ___minus(o:RubyObj):RubyObj
  end
end

interface ImplementsPlusOneArg do
  def ___plus(o:RubyObj):RubyObj
  end
end

interface ImplementsToJavaI do
  def to_java_i():int
  end
end

# LODO should blocks descend from some rubyobj interface maybe?

interface CallableOneArg do
  def call(arg1:RubyObj):RubyObj
  end
end

# LODO within the class, don't need to define parameters, do need $Overide

interface TimesZeroArgBlockOneArg do
  def times(block:CallableOneArg):RubyObj
  end
end

interface BracketOneArg do
  def [](offset:ImplementsToJavaI):RubyObj
  end
end

# interfaces are loosy-goosey! Yes!

class RubyArray < ArrayList # ArrayList<RubyObj> ??
  implements BracketOneArg, ImplementsLessThanLessThanOneArg
  #def <<(o:RubyObj) # ??
  #  add o
  #end
  
  def lessThanLessThan(o:RubyObj)
    add o
    o
  end

  def [](idx:RubyObj):RubyObj 
    # calling to_i is what ruby seems to always do...
    # RubyInt i = ... LODO allow non core classes to be offsets...or maybe I should force them to call their own to_i I'm down with that :P
    RubyObj(get(ImplementsToJavaI(idx).to_java_i))
  end
  
  # TODO []=
  
  def initialize(o:java.util.List)
    addAll(o) # super doesn't work [bug]
  end
  
end

# for demo of what the actual stevia code looks like, see profile_stev class

# same dir means same package ja?
# require 'go2.mir'
