#
# the std lib/common interfaces
#

import java.util.ArrayList

# eventually we'll probably need this for doing "system" or whatever the Kernel shtuff is...
class RubyObj

  # def +(o:Object):RubyObj # rubyobj???
  #   raise 'not yet implemented'
  # end
  # 
  # def -(o:RubyObj):RubyObj # ?? do we need minus here or...should it be ImplementsMinus prolly the latter
  #   raise 'not yet implemented'
  # end

end

interface ImplementsLessThanLessThanOneArg do
  def lessThanLessThan(o:RubyObj):RubyObj
  end
end

interface ImplementsLessThanLessThanOneArg2 do
  def lessThanLessThan33(o:RubyObj):RubyObj
  end
end


interface ImplementsMinusOneArg do
  def -(o:RubyObj):RubyObj
  end
end

interface ImplementsPlusOneArg do
  def +(o:RubyObj):RubyObj
  end
end

interface ImplementsToJavaI do
  def to_java_i():int
  end
end

# LODO should blocks descend from some rubyobj interface maybe?

interface CallableOneArg do
  def call(arg1:RubyObj):RubyObj
  end
end

# LODO within the class, don't need to define parameters, do need $Overide

interface TimesZeroArgBlockOneArg do
  def times(block:CallableOneArg):RubyObj
  end
end

# should I make this class static? cache it [in a hash]?
class RubyInt < RubyObj
  
  implements ImplementsToJavaI
  implements TimesZeroArgBlockOneArg
  implements ImplementsMinusOneArg
  implements ImplementsPlusOneArg
  implements ImplementsLessThanLessThanOneArg2
  
  def initialize(a:int)
    @a = a
  end
  
  def initialize(incoming:RubyObj)
    @a = ImplementsToJavaI(incoming).to_java_i
  end
  
  $Override
  def +(o:RubyObj) # Object? prolly wouldnt help me here...
    # @a is an int
    RubyInt.new(@a + ImplementsToJavaI(o).to_java_i)
  end
  
  # XXX overflow ?

  $Override
  def -(o:RubyObj):RubyObj
    outgoing = @a - ImplementsToJavaI(o).to_java_i
    RubyInt.new(outgoing)
  end

  $Override
  def to_java_i():int
    @a
  end

  $Override
  def toString # any way to provide for free?
    '' + @a
  end
  
  # 
  # this is unsafe though, I think...
  # because what if somebody says
  # 45.times { |n| if b == 41; d = b; end} # and I re-use the entry value
  # they will become confused
  # LODO make this ruby-accessible though, for the casual user :P
  def ___succ!
    @a += 1 # ++
  end

  $Override
  def times(block:CallableOneArg):RubyObj
    x = 0
    while x < @a
        block.call(RubyInt.new(x)) # XXXX reuse the rubyint obj? make it frozen too somehow? FrozenRubyInt? Hmm...went from 4.55 to 4.35 :P
        x += 1
    end
    self
  end

end

interface BracketOneArg do
  def [](offset:ImplementsToJavaI):RubyObj
  end
end

# interfaces are loosy-goosey! Yes!

class RubyArray < ArrayList # ArrayList<RubyObj> ??
  implements BracketOneArg, ImplementsLessThanLessThanOneArg
  #def <<(o:RubyObj) # ??
  #  add o
  #end
  
  def lessThanLessThan(o:RubyObj)
    add o
    o
  end

  def [](idx:RubyObj):RubyObj 
    # calling to_i is what ruby seems to always do...
    # RubyInt i = ... LODO allow non core classes to be offsets...or maybe I should force them to call their own to_i I'm down with that :P
    RubyObj(get(ImplementsToJavaI(idx).to_java_i))
  end
  
  def initialize(o:java.util.List)
    addAll(o) # super doesn't work [bug]
  end
  
end

# for demo of what the actual stevia code looks like, see profile_stev class

# same dir means same package ja?
# require 'go2.mir'

# specs :P

#RubyInt.new(1) - RubyInt.new(2)
#RubyInt.new(1) + RubyInt.new(2)

RubyInt.new(1).times do |n| 
  3
  nil
end

RubyInt.new(1).times do |n| 
  RubyInt.new(1)
end

puts 3