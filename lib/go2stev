#/bin/ruby
import java.util.ArrayList

# eventually we'll probably need this for doing "system" or whatever the Kernel shtuff is...
class RubyObj

  # def +(o:Object):RubyObj # rubyobj???
  #   raise 'not yet implemented'
  # end
  # 
  # def -(o:RubyObj):RubyObj # ?? do we need minus here or...should it be ImplementsMinus prolly the latter
  #   raise 'not yet implemented'
  # end

end

interface ImplementsLessThanLessThanOneArg do
  def lessThanLessThan(o:RubyObj):RubyObj
  end
end

interface ImplementsLessThanLessThanOneArg2 do
  def lessThanLessThan33(o:RubyObj):RubyObj
  end
end


interface ImplementsMinusOneArg do
  def -(o:RubyObj):RubyObj
  end
end

interface ImplementsPlusOneArg do
  def +(o:RubyObj):RubyObj
  end
end

interface ImplementsToI do
  def to_i():int
  end
end

interface CallableOneArg do
  def call(arg1:RubyObj):RubyObj
  end
end

interface TimesZeroArgBlockOneArg do
  def times(block:CallableOneArg):RubyObj
  end
end

# should I make this class static? cache it [in a hash]?
class RubyInt < RubyObj
  
  implements ImplementsToI
  implements TimesZeroArgBlockOneArg
  implements ImplementsMinusOneArg
  implements ImplementsPlusOneArg
  implements ImplementsLessThanLessThanOneArg2
  
  def initialize(a:int) # numeric ?
    @a = a
  end
  
  def initialize(incoming:RubyObj)
    @a = ImplementsToI(incoming).to_i
  end
  
  $Override
  def +(o:RubyObj) # Object? prolly wouldnt help me here...
    # @a is an int
    RubyInt.new(@a + ImplementsToI(o).to_i)
  end
  
  # XXX overflow ?

  $Override
  def -(o:RubyObj):RubyObj
    RubyInt.new(@a - ImplementsToI(o).to_i)
  end

  $Override
  def to_i():int # ummm..shouldn't it complain if I don't have this?
    @a
  end

  $Override
  def toString # any way to provide for free?
    '' + @a
  end
  
  # 
  # this is unsafe though, I think...
  # because what if somebody says
  # 45.times { |n| if b == 41; d = b; end} # and I re-use the entry value
  # they will become confused
  # LODO make this ruby-accessible though, for the casual user :P
  def ___succ!
    @a += 1 # ++
  end

  $Override
  def times(block:CallableOneArg):RubyObj
    x = 0
    while x < @a
        block.call(RubyInt.new(x)) # XXXX reuse the rubyint obj? make it frozen too somehow? FrozenRubyInt? Hmm...went from 4.55 to 4.35 :P
        x += 1
    end
    self
  end

end

interface BracketOneArg do
  def [](offset:ImplementsToI):RubyObj
  end
end

# interfaces are loosy-goosey! Yes!

class RubyArray < ArrayList # ArrayList<RubyObj> ??
  implements BracketOneArg, ImplementsLessThanLessThanOneArg
  #def <<(o:RubyObj) # ??
  #  add o
  #end
  
  def lessThanLessThan(o:RubyObj)
    add o
    o
  end

  def [](idx:RubyObj):RubyObj 
    # calling to_i is what ruby seems to always do...
    RubyObj(get(ImplementsToI(idx).to_i))
  end
  
  def initialize(o:java.util.List)
    addAll(o) # super doesn't work [bug]
  end
  
end

def calcFibN(num:RubyObj)
  fib_array = RubyArray.new [RubyInt.new(0), RubyInt.new(1)]
  
   TimesZeroArgBlockOneArg(ImplementsMinusOneArg(num)-RubyInt.new(2)).times do |i|
  
    # XXXX not need RubyObj class...I think...
    #          fib_array << (fib_array[i] + fib_array[i+1])
    eyePlusOne = ImplementsPlusOneArg(i)+ RubyInt.new(1)
    new_entry = ImplementsPlusOneArg(fib_array[i]) + fib_array[eyePlusOne]
    # add it to array
    ImplementsLessThanLessThanOneArg(fib_array).lessThanLessThan(new_entry)
  end
  # puts fib_array
end

 
3_000_000.times {
  calcFibN(RubyInt.new(30))
}

#puts 'worked'

